package leetcode.easy;

import org.junit.Test;

public class P461 {
	
	/**
	 * 另外一种思路是如果一个整数不为0，那么这个整数至少
	 * 有一位是1。如果我们把这个整数减去1，那么原来处在
	 * 整数最右边的1就会变成0，原来在1后面的所有的0都会变
	 * 成1。其余的所有位将不受到影响。举个例子：一个二进制
	 * 数1100，从右边数起的第三位是处于最右边的一个1。减
	 * 去1后，第三位变成0，它后面的两位0变成1，而前面的1
	 * 保持不变，因此得到结果是1011。我们发现减1的结果是
	 * 把从最右边一个1开始的所有位都取反了。这个时候如果
	 * 我们再把原来的整数和减去1之后的结果做与运算，从原
	 * 来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000。
	 * 也就是说，把一个整数减去1，再和原整数做与运算，会把该整
	 * 数最右边一个1变成0。那么一个整数的二进制有多少个1，就可以
	 * 进行多少次这样的操作。
	 * @param x
	 * @param y
	 * @return
	 */
	 public int hammingDistance(int x, int y) {
		int i = x ^ y; //与运算 0^0=0  1^1=0  1^0=1  0^1=1
	    int count=0;
	    while (i != 0) {
	        ++ count;
	        i = (i-1)& i;
	    }
	    return count;
	    
	 }

	 @Test
	 public void test(){
		 
		 int a =6;
		 int b =5;
		 System.out.println( a ^ b);
	 }
}
